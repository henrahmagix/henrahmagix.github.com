---
layout: playground
title: Fez tools
---

<h2>Writing</h2>

<p>Use this to encode and decode the writing language in <a href="https://en.wikipedia.org/wiki/Fez_%28video_game%29">Fez</a>. Input English to output Fezzish (or whatever the language is called!) or input Fezzish to output English.</p>

<p>The English is saved to <code>localStorage</code> so you can come back later and not lose your translations ðŸ¤—</p>

<p>The Fez language is written like Japanese: top to bottom, right to left. Whilst the vertically-written directional secrets in Fez are meant to be read with your head tilted to the right by 90Â°, I have decoded this text without any head-tilting. The decoding here can be confirmed by the "Quick brown foxâ€¦" text (spoiler lol sorry!).</p>

<form>
  <fieldset id="fez_to_text">
    <legend>Fez glyph set</legend>
    <p>Select a Fez glyph to add it's corresponding English letter to the end of the English text. Keyboard navigation works as expected, plus you can use the arrow keys to navigate, and <code><kbd><kbd>Shift</kbd>+<kbd>Space</kbd></kbd></code> will add a space, whilst <code><kbd><kbd>Shift</kbd>+<kbd>Enter</kbd></kbd></code> will add a newline.</p>
    <p>Each Fez glyph has a <code>title</code> attribute with the English letter. <code>U</code> and <code>V</code> share the same Fez glyph, as do <code>K</code> and <code>Q</code>. If an input character is unknown, it will show <img class="glyph" id="not_found_glyph" style="display: inline-block; vertical-align: middle;"></p>
    <input type="checkbox" id="toggle_alphabet_order">
    <label for="toggle_alphabet_order">Order alphabetically?</label>
    <div id="alphabet_buttons"></div>

    <p>These are directional glyphs:</p>
    <div id="direction_set"></div>
  </fieldset>

  <div id="text_to_fez">
    <div>
      <label for="fez_text_input">English</label>
      <textarea id="fez_text_input" cols=20 rows=20 class="monospace">
the quick
brown
fox

jumps
over
the lazy
dog</textarea>
    <button id="swap_uv_kq" type="button">Swap <code>u/v</code> and <code>k/q</code></button>
    </div>

    <div class="image-scroller-wrapper">
      <label for="fez_image_output">Fezzish</label>
      <div class="image-scroller">
        <img id="fez_image_output">
      </div>
    </div>
  </div>
</form>

<style>
  textarea {
    display: block;
    line-height: 1.2;
    height: 360px;
  }
  #swap_uv_kq {
    display: block;
  }
  #text_to_fez {
    display: flex;
  }
  .image-scroller-wrapper {
    overflow: auto;
  }
  .image-scroller {
    display: block;
    white-space: nowrap;
    overflow: auto;
  }
  .image-scroller img {
    display: block;
    max-width: none;
    max-height: 360px;
    object-fit: contain;
    object-position: top left;
  }
  #text_to_fez label {
    display: block;
    margin: 0.5em 0;
  }
  #fez_to_text button {
    display: inline-block;
  }
  .glyph {
    display: block;
    margin: 2px;
  }

  @media (prefers-color-scheme: dark) {
    #fez_image_output, .glyph {
      filter: invert();
    }
  }

</style>

<script>
String.prototype.toFezGlyph = function () {
  return this.split(',').map(function (s) { return s.split('') });
};

(function () {
  var glyphScale = 4;
  var glyphSize = 5;

  var NOT_FOUND_GLYPH = '10101,01010,10101,01010,10101'.toFezGlyph();

  var alphabetGlyphs = {
    a: '00000,11011,01110,00000,00000'.toFezGlyph(),
    b: '00000,01110,01010,11110,00000'.toFezGlyph(),
    c: '00000,00011,00010,00011,00000'.toFezGlyph(),
    d: '00000,00000,00000,11000,01000'.toFezGlyph(),
    e: '00000,11000,01000,01111,00000'.toFezGlyph(),
    f: '00000,01010,11110,01010,00000'.toFezGlyph(),
    g: '00010,00110,00100,00110,00010'.toFezGlyph(),
    h: '00000,01110,01010,01110,00010'.toFezGlyph(),
    i: '01010,01110,00000,00000,00000'.toFezGlyph(),
    j: '00000,00000,00000,00011,00010'.toFezGlyph(),
    k: '00010,00010,00010,01110,01000'.toFezGlyph(),
    l: '00000,01110,00100,01110,00100'.toFezGlyph(),
    m: '00000,00000,01110,11011,00000'.toFezGlyph(),
    n: '00000,01111,01010,01110,00000'.toFezGlyph(),
    o: '00000,11000,01000,11000,00000'.toFezGlyph(),
    p: '00010,00011,00000,00000,00000'.toFezGlyph(),
    q: '00010,00010,00010,01110,01000'.toFezGlyph(),
    r: '00000,01010,01111,01010,00000'.toFezGlyph(),
    s: '01000,01100,00100,01100,01000'.toFezGlyph(),
    t: '01000,01110,01010,01110,00000'.toFezGlyph(),
    u: '00000,00000,00000,01110,01010'.toFezGlyph(),
    v: '00000,00000,00000,01110,01010'.toFezGlyph(),
    w: '01000,11000,00000,00000,00000'.toFezGlyph(),
    x: '00010,01110,01000,01000,01000'.toFezGlyph(),
    y: '00100,01110,00100,01110,00000'.toFezGlyph(),
    z: '00000,11110,00010,00011,00000'.toFezGlyph()
  };

  var directionalGlyphPairs = {
    '[up]': ['00000,01010,01010,01110,00000'.toFezGlyph(), '00000,00000,00100,01110,00000'.toFezGlyph()],
    '[right]': ['00000,01010,00010,01110,00000'.toFezGlyph(), '00000,01000,01100,01000,00000'.toFezGlyph()],
    '[down]': ['00000,01010,00000,01110,00000'.toFezGlyph(), '00000,01110,00100,00000,00000'.toFezGlyph()],
    '[left]': ['00000,01110,01010,01010,00000'.toFezGlyph(), '00000,00010,00110,00010,00000'.toFezGlyph()],
    '[rotate left]': ['00000,01110,00000,01110,00000'.toFezGlyph(), '00000,01100,00110,00000,00000'.toFezGlyph()],
    '[rotate right]': ['00000,01110,01000,01110,00000'.toFezGlyph(), '00000,00110,01100,00000,00000'.toFezGlyph()],
    '[jump]': ['00000,01110,00010,01110,00000'.toFezGlyph(), '00000,01100,01100,00000,00000'.toFezGlyph()]
  };

  var textToFez = document.getElementById('text_to_fez');
  var fezToText = document.getElementById('fez_to_text');

  var textInput = textToFez.querySelector('textarea');
  textInput.addEventListener('input', updateFromTextInput);
  var outputImg = document.getElementById('fez_image_output');
  var outputCanvas = document.createElement('canvas');
  var outputCtx = outputCanvas.getContext('2d');

  var savedText = localStorage.getItem('henryblythcom_playground_fez_text');
  if (savedText) {
    var numlines = savedText.split('').filter(function (s) { return s === '\n' }).length;
    if (Number.isInteger(numlines)) {
      textInput.rows = numlines + 1;
    }
    textInput.value = savedText;
  }
  updateFromTextInput();

  document.getElementById('swap_uv_kq').addEventListener('click', function () {
    textInput.value = textInput.value.replace(/u/g, 'V').replace(/v/g, 'U').replace(/k/g, 'Q').replace(/q/g, 'K').toLowerCase();
    updateFromTextInput();
  });

  function updateFromTextInput() {
    localStorage.setItem('henryblythcom_playground_fez_text', textInput.value);
    drawLettersFromText(outputCanvas, outputCtx, textInput.value);
    outputImg.width = outputCanvas.width;
    outputImg.height = outputCanvas.height;
    outputImg.src = outputCanvas.toDataURL();
  }

  var fezGlyphBuilderCanvas = document.createElement('canvas');

  var fezAlphabetChooser = document.getElementById('alphabet_buttons');
  var alphabetOrderByGlyph = 'agmstnhbicuvopjdwkqexzlfyr';
  var alphabetOrderAlphabetically = 'abcdefghijklmnopqrstuvwxyz';

  var alphabetOrderToggle = /** @type {HTMLInputElement} */ (document.getElementById('toggle_alphabet_order'));
  alphabetOrderToggle.addEventListener('change', function () { buildAlphabetChooser(alphabetOrderToggle.checked ? alphabetOrderAlphabetically : alphabetOrderByGlyph) });

  var currentAlphabetOrder = localStorage.getItem('henryblythcom_playground_fez_alphabet_order') || alphabetOrderByGlyph;
  buildAlphabetChooser(currentAlphabetOrder);
  alphabetOrderToggle.checked = currentAlphabetOrder === alphabetOrderAlphabetically;

  function buildAlphabetChooser(order) {
    localStorage.setItem('henryblythcom_playground_fez_alphabet_order', order);
    fezGlyphBuilderCanvas.width = glyphSize * glyphScale;
    fezGlyphBuilderCanvas.height = fezGlyphBuilderCanvas.width;
    var fezGlyphBuilderCtx = fezGlyphBuilderCanvas.getContext('2d');
    fezAlphabetChooser.textContent = '';
    order.split('').forEach(function (char) {
      var button = document.createElement('button');
      button.className = 'button-link';
      button.type = 'button';
      button.title = char;
      button.onclick = function () { typeChar(char) };
      button.onkeydown = onFezChoiceButtonKeyDown;

      var glyph = alphabetGlyphs[char];
      drawGlyph(fezGlyphBuilderCtx, glyph, 0, 0);
      var img = new Image();
      img.className = 'glyph';
      img.alt = char;
      img.src = fezGlyphBuilderCanvas.toDataURL();
      button.append(img, char);
      fezAlphabetChooser.append(button);
    });
  }

  var fezDirectionSet = document.getElementById('direction_set');
  fezGlyphBuilderCanvas.width = glyphSize * glyphScale;
  fezGlyphBuilderCanvas.height = fezGlyphBuilderCanvas.width * 2;
  ['[up]', '[right]', '[down]', '[left]', '[rotate left]', '[rotate right]', '[jump]'].forEach(function (direction) {
    var button = document.createElement('button');
    button.className = 'button-link';
    button.type = 'button';
    button.title = 'Type ' + direction;
    button.onclick = function () { typeChar(direction) };
    button.onkeydown = onFezChoiceButtonKeyDown;

    directionalGlyphPairs[direction].forEach(function (glyph, i) {
      drawGlyph(fezGlyphBuilderCtx, glyph, 0, i * (fezGlyphBuilderCanvas.height / 2));
    });

    var img = new Image();
    img.className = 'glyph';
    img.alt = direction;
    img.src = fezGlyphBuilderCanvas.toDataURL();
    button.append(img, direction);
    fezDirectionSet.append(button);
  });

  var notFoundGlyphImg = document.getElementById('not_found_glyph');
  notFoundGlyphImg.alt = 'unknown character';
  fezGlyphBuilderCanvas.width = glyphSize * glyphScale;
  fezGlyphBuilderCanvas.height = fezGlyphBuilderCanvas.width;
  drawGlyph(fezGlyphBuilderCtx, NOT_FOUND_GLYPH, 0, 0);
  notFoundGlyphImg.src = fezGlyphBuilderCanvas.toDataURL();

  function typeChar(char) {
    textInput.value += char;
    updateFromTextInput();
  }

  function typeBackspace() {
    textInput.value = textInput.value.slice(0, -1);
  }

  /** @param {KeyboardEvent} e */
  function onFezChoiceButtonKeyDown(e) {
    if (e.shiftKey && e.code === 'Space') {
      typeChar(' ');
      return false;
    } else if (e.shiftKey && e.code === 'Enter') {
      typeChar('\n');
      return false;
    } else if (e.code === 'Backspace') {
      typeBackspace();
      return false;
    } else if (e.code === 'ArrowLeft' || e.code === 'ArrowUp') {
      var prev = e.target.previousElementSibling || e.target.parentElement.lastElementChild;
      if (prev && prev.focus) {
        prev.focus();
        return false;
      }
    } else if (e.code === 'ArrowRight' || e.code === 'ArrowDown') {
      var next = e.target.nextElementSibling || e.target.parentElement.firstElementChild;
      if (next && next.focus) {
        next.focus();
        return false;
      }
    }
  }

  function drawLettersFromText(canvas, ctx, string) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    var lines = string.split('\n').map(function (s) { return s.match(/\[[^\]]+\]|./g) });
    var gap = glyphScale;
    var charSize = glyphSize * glyphScale

    var longestLineLength = lines.reduce(function (n, l) { var len = l ? l.length : 0; return len > n ? len : n }, 0);
    var cw = canvas.width = lines.length * (charSize + gap);
    var ch = canvas.height = longestLineLength * (charSize + gap);

    lines.forEach(function (chars, linenum) {
      chars && chars.forEach(function (char, i) {
        if (char !== ' ') {
          var glyph = alphabetGlyphs[char];
          if (!glyph) {
            glyph = directionalGlyphPairs[char];
            glyph = glyph && glyph[0] || NOT_FOUND_GLYPH;
          }
          var x = cw - charSize - (charSize * linenum) - (gap * linenum);
          var y = (charSize * i) + (gap * i)
          drawGlyph(ctx, glyph, x, y);
        }
        i++;
      });
    });
  }

  function drawGlyph(ctx, glyph, x, y) {
    var xMax = glyph[0].length;
    var yMax = glyph.length;
    for (var ix = 0; ix < xMax; ix++) {
      for (var iy = 0; iy < yMax; iy++) {
        var xFill = x + (ix * glyphScale);
        var yFill = y + (iy * glyphScale);
        // Fill every pixel so glyphs don't mix together when overwriting.
        ctx.fillStyle = glyph[iy][ix] === '1' ? 'white' : 'black';
        ctx.fillRect(xFill, yFill, glyphScale, glyphScale)
      }
    }
  }
}());
</script>
